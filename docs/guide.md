# 가이드라인

초심자를 위한 가이드라인으로 상황에 맞게 사용하면 된다.    

## 1단계 - 데드락 발생

`com.aengdulab.ticket.MissionTest` 테스트 코드를 실행하면 데드락이 발생한다. 로그를 확인하고 데드락을 해결해보자.

### 📌 원인
- MemberTicket 엔티티에 Member와 Ticket의 외래키(Foreign Key) 가 걸려 있다.
- 외래키로 인해 S Lock이 걸리고, 티켓 재고를 줄이기 위해 X Lock을 걸려고 하지만, 다른 트랜잭션도 같은 작업을 시도하여 데드락 발생한다. 
- S Lock과 X Lock이 걸리는 이유가 무엇일까? 어떻게 해결할 수 있을까? 

### 📌 데드락 확인 방법
다음 쿼리를 실행하여 데드락이 발생한 상황을 확인할 수 있다.  
```sql
SHOW ENGINE INNODB STATUS\G;
```

## 2단계 - 티켓이 모두 팔렸지만 재고가 0이 아닌 문제

### 📌 원인
- 모든 스레드가 동시에 티켓 재고를 조회(10장)한 후 10-1=9로 업데이트한다.
- 조회 시점이 다른 스레드의 업데이트보다 늦기 때문에 동시성 문제 발생한다. 
- 위 현상을 lost update라고 하는데, 방지하려면 어떻게 해야 할까?

### ❌ 잘못된 해결 방법 - `synchronized` 키워드 사용
- `synchronized` 키워드를 서비스 메서드에 추가하는 방법으로 간단하게 해결할 수 없다. 
- `synchronized` 키워드는 동시성을 제어하는 방법인데, 왜 문제를 해결할 수 없을까? @Transactional의 동작 원리를 알아보자. 

### ❌ 잘못된 해결 방법 - 낙관적 락 사용
- 낙관적 락은 경합이 적은 환경에서 사용하기 적절한 방법이다. 하지만 경합이 심한 환경(초당 수천 건의 요청) 에서는 충돌이 빈번하게 발생한다. 
- 충돌이 발생하면 하나의 요청만 성공하고 나머지는 실패한다. 
- 재시도 로직을 추가하면 문제 해결 가능하지만, 요청 순서를 보장하지 않는다.  

## 3단계 - 그 외에 고려할 만한 문제

기술적 해결뿐만 아니라, 서비스와 아키텍처적인 측면에서도 고려해야 할 문제들이 존재한다.  
이 단계에서는 비즈니스 로직, 분산 환경, 운영 방식까지 포함하여 전반적인 해결 방법을 고민해 보자.  

### 📌 서비스적인 접근 방식
꼭 기술로만 해결해야 할까? 서비스 수준에서 해결할 수 있는 방법은 없을까?  
서비스적인 접근 방식을 적용하면, 기술적으로 해결하기 어려운 문제를 더 쉽게 해결할 수 있다. 

- 티켓 구매를 선착순이 아닌 추첨제로 운영
- 서버에 동시에 요청이 몰리는 것을 방지하고, 사용자를 대기열에 넣은 후 순차적으로 처리

### 📌 분산 환경에서의 문제
- 단일 MySQL DB 서버에서는 MySQL 락으로 동시성을 제어할 수 있지만, 분산 환경에서는 다르다.  
- 일반적인 트랜잭션과 락은 단일 DB 서버에서만 동작한다. 분산 환경에서는 어떻게 해결해야 할까? 
